/**
 * Generated by orval v7.11.2 🍺
 * Do not edit manually.
 * Meeting Transcriber API
 * API for audio upload/conversion, transcription (with optional speaker diarization), and meeting notes generation via Ollama.

Base app defined in `backend/app/main.py`. Routers mounted under `/api/v1`.

 * OpenAPI spec version: 0.1.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  AudioProcessingQueued,
  AudioProcessingStatus,
  ErrorResponse,
  GenerateNotesParams,
  GenerateNotesResponse,
  HealthResponse,
  OllamaStatus,
  StartTranscriptionParams,
  TranscriptionQueued,
  TranscriptionStatus,
  UploadAudioBody
} from './model';

import { customFetcher } from '../http';
/**
 * @summary Health check
 */
export type getRootResponse200 = {
  data: HealthResponse
  status: 200
}
    
export type getRootResponseComposite = getRootResponse200;
    
export type getRootResponse = getRootResponseComposite & {
  headers: Headers;
}

export const getGetRootUrl = () => {


  

  return `/`
}

export const getRoot = async ( options?: RequestInit): Promise<getRootResponse> => {
  
  return customFetcher<getRootResponse>(getGetRootUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



export const getGetRootQueryKey = () => {
    return [`/`] as const;
    }

    
export const getGetRootQueryOptions = <TData = Awaited<ReturnType<typeof getRoot>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRoot>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRootQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRoot>>> = ({ signal }) => getRoot(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getRoot>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetRootQueryResult = NonNullable<Awaited<ReturnType<typeof getRoot>>>
export type GetRootQueryError = unknown


export function useGetRoot<TData = Awaited<ReturnType<typeof getRoot>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRoot>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRoot>>,
          TError,
          Awaited<ReturnType<typeof getRoot>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRoot<TData = Awaited<ReturnType<typeof getRoot>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRoot>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRoot>>,
          TError,
          Awaited<ReturnType<typeof getRoot>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRoot<TData = Awaited<ReturnType<typeof getRoot>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRoot>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Health check
 */

export function useGetRoot<TData = Awaited<ReturnType<typeof getRoot>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRoot>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetRootQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Upload and convert audio to standard WAV (async)
 */
export type uploadAudioResponse200 = {
  data: AudioProcessingQueued
  status: 200
}

export type uploadAudioResponse400 = {
  data: ErrorResponse
  status: 400
}

export type uploadAudioResponse500 = {
  data: ErrorResponse
  status: 500
}
    
export type uploadAudioResponseComposite = uploadAudioResponse200 | uploadAudioResponse400 | uploadAudioResponse500;
    
export type uploadAudioResponse = uploadAudioResponseComposite & {
  headers: Headers;
}

export const getUploadAudioUrl = () => {


  

  return `/api/v1/upload-audio`
}

export const uploadAudio = async (uploadAudioBody: UploadAudioBody, options?: RequestInit): Promise<uploadAudioResponse> => {
    const formData = new FormData();
formData.append(`file`, uploadAudioBody.file)

  return customFetcher<uploadAudioResponse>(getUploadAudioUrl(),
  {      
    ...options,
    method: 'POST'
    ,
    body: 
      formData,
  }
);}




export const getUploadAudioMutationOptions = <TError = ErrorResponse | ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof uploadAudio>>, TError,{data: UploadAudioBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof uploadAudio>>, TError,{data: UploadAudioBody}, TContext> => {

const mutationKey = ['uploadAudio'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof uploadAudio>>, {data: UploadAudioBody}> = (props) => {
          const {data} = props ?? {};

          return  uploadAudio(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UploadAudioMutationResult = NonNullable<Awaited<ReturnType<typeof uploadAudio>>>
    export type UploadAudioMutationBody = UploadAudioBody
    export type UploadAudioMutationError = ErrorResponse | ErrorResponse

    /**
 * @summary Upload and convert audio to standard WAV (async)
 */
export const useUploadAudio = <TError = ErrorResponse | ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof uploadAudio>>, TError,{data: UploadAudioBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof uploadAudio>>,
        TError,
        {data: UploadAudioBody},
        TContext
      > => {

      const mutationOptions = getUploadAudioMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary Get audio processing status
 */
export type getAudioProcessingStatusResponse200 = {
  data: AudioProcessingStatus
  status: 200
}

export type getAudioProcessingStatusResponse404 = {
  data: ErrorResponse
  status: 404
}
    
export type getAudioProcessingStatusResponseComposite = getAudioProcessingStatusResponse200 | getAudioProcessingStatusResponse404;
    
export type getAudioProcessingStatusResponse = getAudioProcessingStatusResponseComposite & {
  headers: Headers;
}

export const getGetAudioProcessingStatusUrl = (taskId: string,) => {


  

  return `/api/v1/audio-processing/${taskId}`
}

export const getAudioProcessingStatus = async (taskId: string, options?: RequestInit): Promise<getAudioProcessingStatusResponse> => {
  
  return customFetcher<getAudioProcessingStatusResponse>(getGetAudioProcessingStatusUrl(taskId),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



export const getGetAudioProcessingStatusQueryKey = (taskId?: string,) => {
    return [`/api/v1/audio-processing/${taskId}`] as const;
    }

    
export const getGetAudioProcessingStatusQueryOptions = <TData = Awaited<ReturnType<typeof getAudioProcessingStatus>>, TError = ErrorResponse>(taskId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAudioProcessingStatus>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAudioProcessingStatusQueryKey(taskId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAudioProcessingStatus>>> = ({ signal }) => getAudioProcessingStatus(taskId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(taskId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAudioProcessingStatus>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAudioProcessingStatusQueryResult = NonNullable<Awaited<ReturnType<typeof getAudioProcessingStatus>>>
export type GetAudioProcessingStatusQueryError = ErrorResponse


export function useGetAudioProcessingStatus<TData = Awaited<ReturnType<typeof getAudioProcessingStatus>>, TError = ErrorResponse>(
 taskId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAudioProcessingStatus>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAudioProcessingStatus>>,
          TError,
          Awaited<ReturnType<typeof getAudioProcessingStatus>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAudioProcessingStatus<TData = Awaited<ReturnType<typeof getAudioProcessingStatus>>, TError = ErrorResponse>(
 taskId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAudioProcessingStatus>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAudioProcessingStatus>>,
          TError,
          Awaited<ReturnType<typeof getAudioProcessingStatus>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAudioProcessingStatus<TData = Awaited<ReturnType<typeof getAudioProcessingStatus>>, TError = ErrorResponse>(
 taskId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAudioProcessingStatus>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get audio processing status
 */

export function useGetAudioProcessingStatus<TData = Awaited<ReturnType<typeof getAudioProcessingStatus>>, TError = ErrorResponse>(
 taskId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAudioProcessingStatus>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAudioProcessingStatusQueryOptions(taskId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Start transcription for a completed audio processing task
 */
export type startTranscriptionResponse200 = {
  data: TranscriptionQueued
  status: 200
}

export type startTranscriptionResponse400 = {
  data: ErrorResponse
  status: 400
}

export type startTranscriptionResponse404 = {
  data: ErrorResponse
  status: 404
}

export type startTranscriptionResponse500 = {
  data: ErrorResponse
  status: 500
}
    
export type startTranscriptionResponseComposite = startTranscriptionResponse200 | startTranscriptionResponse400 | startTranscriptionResponse404 | startTranscriptionResponse500;
    
export type startTranscriptionResponse = startTranscriptionResponseComposite & {
  headers: Headers;
}

export const getStartTranscriptionUrl = (processingTaskId: string,
    params?: StartTranscriptionParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/v1/transcribe/${processingTaskId}?${stringifiedParams}` : `/api/v1/transcribe/${processingTaskId}`
}

export const startTranscription = async (processingTaskId: string,
    params?: StartTranscriptionParams, options?: RequestInit): Promise<startTranscriptionResponse> => {
  
  return customFetcher<startTranscriptionResponse>(getStartTranscriptionUrl(processingTaskId,params),
  {      
    ...options,
    method: 'POST'
    
    
  }
);}




export const getStartTranscriptionMutationOptions = <TError = ErrorResponse | ErrorResponse | ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof startTranscription>>, TError,{processingTaskId: string;params?: StartTranscriptionParams}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof startTranscription>>, TError,{processingTaskId: string;params?: StartTranscriptionParams}, TContext> => {

const mutationKey = ['startTranscription'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof startTranscription>>, {processingTaskId: string;params?: StartTranscriptionParams}> = (props) => {
          const {processingTaskId,params} = props ?? {};

          return  startTranscription(processingTaskId,params,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type StartTranscriptionMutationResult = NonNullable<Awaited<ReturnType<typeof startTranscription>>>
    
    export type StartTranscriptionMutationError = ErrorResponse | ErrorResponse | ErrorResponse

    /**
 * @summary Start transcription for a completed audio processing task
 */
export const useStartTranscription = <TError = ErrorResponse | ErrorResponse | ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof startTranscription>>, TError,{processingTaskId: string;params?: StartTranscriptionParams}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof startTranscription>>,
        TError,
        {processingTaskId: string;params?: StartTranscriptionParams},
        TContext
      > => {

      const mutationOptions = getStartTranscriptionMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary Get transcription status/result
 */
export type getTranscriptionResponse200 = {
  data: TranscriptionStatus
  status: 200
}

export type getTranscriptionResponse404 = {
  data: ErrorResponse
  status: 404
}
    
export type getTranscriptionResponseComposite = getTranscriptionResponse200 | getTranscriptionResponse404;
    
export type getTranscriptionResponse = getTranscriptionResponseComposite & {
  headers: Headers;
}

export const getGetTranscriptionUrl = (taskId: string,) => {


  

  return `/api/v1/transcribe/${taskId}`
}

export const getTranscription = async (taskId: string, options?: RequestInit): Promise<getTranscriptionResponse> => {
  
  return customFetcher<getTranscriptionResponse>(getGetTranscriptionUrl(taskId),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



export const getGetTranscriptionQueryKey = (taskId?: string,) => {
    return [`/api/v1/transcribe/${taskId}`] as const;
    }

    
export const getGetTranscriptionQueryOptions = <TData = Awaited<ReturnType<typeof getTranscription>>, TError = ErrorResponse>(taskId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTranscription>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetTranscriptionQueryKey(taskId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getTranscription>>> = ({ signal }) => getTranscription(taskId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(taskId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getTranscription>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetTranscriptionQueryResult = NonNullable<Awaited<ReturnType<typeof getTranscription>>>
export type GetTranscriptionQueryError = ErrorResponse


export function useGetTranscription<TData = Awaited<ReturnType<typeof getTranscription>>, TError = ErrorResponse>(
 taskId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTranscription>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTranscription>>,
          TError,
          Awaited<ReturnType<typeof getTranscription>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetTranscription<TData = Awaited<ReturnType<typeof getTranscription>>, TError = ErrorResponse>(
 taskId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTranscription>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTranscription>>,
          TError,
          Awaited<ReturnType<typeof getTranscription>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetTranscription<TData = Awaited<ReturnType<typeof getTranscription>>, TError = ErrorResponse>(
 taskId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTranscription>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get transcription status/result
 */

export function useGetTranscription<TData = Awaited<ReturnType<typeof getTranscription>>, TError = ErrorResponse>(
 taskId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTranscription>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetTranscriptionQueryOptions(taskId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Generate meeting notes from a completed transcription
 */
export type generateNotesResponse200 = {
  data: GenerateNotesResponse
  status: 200
}

export type generateNotesResponse400 = {
  data: ErrorResponse
  status: 400
}

export type generateNotesResponse404 = {
  data: ErrorResponse
  status: 404
}

export type generateNotesResponse500 = {
  data: ErrorResponse
  status: 500
}

export type generateNotesResponse503 = {
  data: ErrorResponse
  status: 503
}
    
export type generateNotesResponseComposite = generateNotesResponse200 | generateNotesResponse400 | generateNotesResponse404 | generateNotesResponse500 | generateNotesResponse503;
    
export type generateNotesResponse = generateNotesResponseComposite & {
  headers: Headers;
}

export const getGenerateNotesUrl = (taskId: string,
    params?: GenerateNotesParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/v1/generate-notes/${taskId}?${stringifiedParams}` : `/api/v1/generate-notes/${taskId}`
}

export const generateNotes = async (taskId: string,
    params?: GenerateNotesParams, options?: RequestInit): Promise<generateNotesResponse> => {
  
  return customFetcher<generateNotesResponse>(getGenerateNotesUrl(taskId,params),
  {      
    ...options,
    method: 'POST'
    
    
  }
);}




export const getGenerateNotesMutationOptions = <TError = ErrorResponse | ErrorResponse | ErrorResponse | ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof generateNotes>>, TError,{taskId: string;params?: GenerateNotesParams}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof generateNotes>>, TError,{taskId: string;params?: GenerateNotesParams}, TContext> => {

const mutationKey = ['generateNotes'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof generateNotes>>, {taskId: string;params?: GenerateNotesParams}> = (props) => {
          const {taskId,params} = props ?? {};

          return  generateNotes(taskId,params,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type GenerateNotesMutationResult = NonNullable<Awaited<ReturnType<typeof generateNotes>>>
    
    export type GenerateNotesMutationError = ErrorResponse | ErrorResponse | ErrorResponse | ErrorResponse

    /**
 * @summary Generate meeting notes from a completed transcription
 */
export const useGenerateNotes = <TError = ErrorResponse | ErrorResponse | ErrorResponse | ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof generateNotes>>, TError,{taskId: string;params?: GenerateNotesParams}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof generateNotes>>,
        TError,
        {taskId: string;params?: GenerateNotesParams},
        TContext
      > => {

      const mutationOptions = getGenerateNotesMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary Check Ollama availability and models
 */
export type getOllamaStatusResponse200 = {
  data: OllamaStatus
  status: 200
}
    
export type getOllamaStatusResponseComposite = getOllamaStatusResponse200;
    
export type getOllamaStatusResponse = getOllamaStatusResponseComposite & {
  headers: Headers;
}

export const getGetOllamaStatusUrl = () => {


  

  return `/api/v1/ollama/status`
}

export const getOllamaStatus = async ( options?: RequestInit): Promise<getOllamaStatusResponse> => {
  
  return customFetcher<getOllamaStatusResponse>(getGetOllamaStatusUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



export const getGetOllamaStatusQueryKey = () => {
    return [`/api/v1/ollama/status`] as const;
    }

    
export const getGetOllamaStatusQueryOptions = <TData = Awaited<ReturnType<typeof getOllamaStatus>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOllamaStatus>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetOllamaStatusQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getOllamaStatus>>> = ({ signal }) => getOllamaStatus(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getOllamaStatus>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetOllamaStatusQueryResult = NonNullable<Awaited<ReturnType<typeof getOllamaStatus>>>
export type GetOllamaStatusQueryError = unknown


export function useGetOllamaStatus<TData = Awaited<ReturnType<typeof getOllamaStatus>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOllamaStatus>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOllamaStatus>>,
          TError,
          Awaited<ReturnType<typeof getOllamaStatus>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetOllamaStatus<TData = Awaited<ReturnType<typeof getOllamaStatus>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOllamaStatus>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOllamaStatus>>,
          TError,
          Awaited<ReturnType<typeof getOllamaStatus>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetOllamaStatus<TData = Awaited<ReturnType<typeof getOllamaStatus>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOllamaStatus>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Check Ollama availability and models
 */

export function useGetOllamaStatus<TData = Awaited<ReturnType<typeof getOllamaStatus>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOllamaStatus>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetOllamaStatusQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}
